checkpoint generate_table_summary:
    conda: '../envs/simulate_reads.yml'

    input: 'table_combined.tsv'

    output: 'metagenome_summary.tsv'

    params: proportion_reads = config['proportion_reads']

    script: 'calculate_reads.py'


rule decompress_assemblies:
    conda: '../envs/simulate_reads.yml'

    input: 'assembly_gz/{sample}.fna.gz'

    output: temp('simreads/{sample}.fna')

    shell: 'zcat {input[0]} > {output[0]}'


rule concat_scaffolds:
    input: 'simreads/{sample}.fna'

    output: temp('simreads/{sample,[A-Za-z0-9_\.]}.fna')

    shell: "sed '1!{{/^>/d;}}' {input[0]} > {output[0]}"

import pandas as pd
import numpy as np
def calculate_reads(wildcards):
    total=config['total_amount_reads']
    checkpoint_output = checkpoints.generate_table_summary.get(**wildcards).output[0]
    table=pd.read_csv(checkpoint_output,delimiter='\t',index_col=0)
    prop=table.loc[wildcards.sample]['PercentReads']
    read_nb=int(prop*total)
    mean=read_nb
    sd=2.0
    read_nb_sample=round(np.random.normal(mean,sd))
    #This adds variability for the number of simulated reads between replicates
    print('Simulating {} reads'.format(read_nb_sample))
    return read_nb_sample

rule generate_reads_single:
    conda: '../envs/simulate_reads.yml'

    input: 'simreads/{sample}.fna'

    output: temp('simreads/single_simrep{rep,[A-Za-z0-9_\.]}_{sample,[A-Za-z0-9_\.]+}_R1.fq')

    params: seq_system=config['illumina_sequencing_system'],
            read_length=config['read_length'],
            read_num=calculate_reads

    resources: nb_simulation=1

    shell: 'art_illumina -ss {params.seq_system} -na -i {input} \
    -l {params.read_length} -c {params.read_num} -o simreads/single_simrep{wildcards.rep}_{wildcards.sample}_R1'


rule generate_reads_paired:
    conda: '../envs/simulate_reads.yml'

    input: 'simreads/{sample}.fna'

    output: temp('simreads/paired_simrep{rep,[A-Za-z0-9_\.]}_{sample,[A-Za-z0-9_\.]+}_R1.fq'),
            temp('simreads/paired_simrep{rep,[A-Za-z0-9_\.]}_{sample,[A-Za-z0-9_\.]+}_R2.fq')

    params: seq_system=config['illumina_sequencing_system'],
            read_length=config['read_length'],
            read_num=calculate_reads,
            mean_frag_len=config['mean_fragment_length'],
            sd=config['sd_fragment_length']

    resources: nb_simulation=1

    shell: 'art_illumina -ss {params.seq_system} -na -i {input} -p -m {params.mean_frag_len} -s {params.sd} \
    -l {params.read_length} -c {params.read_num} -o simreads/paired_simrep{wildcards.rep}_{wildcards.sample}_R'

def list_samples(wildcards):
    checkpoint_output = checkpoints.generate_table_summary.get(**wildcards).output[0]
    table=pd.read_csv(checkpoint_output,delimiter='\t')
    acc=list(table['AssemblyNames'])
    expd=expand('simreads/{format}_simrep{{rep}}_{sample}_R{{rd}}.fq',sample=acc,format=config["read_status"])
    return expd


rule combine_fastq:
    input: list_samples

    output: temp('simreads/{rep}_combined_reads_R{rd}.fq')

    shell:
        '''
        cat {input} >> {output}
        '''

pipeline_path=workflow.basedir+'/'


rule shuffle_fastq:
    input: 'simreads/{rep}_combined_reads_R{rd}.fq'

    output: 'simreads/{community}/simrep_{rep}/R{rd}.fq'

    params: script_path=pipeline_path+'rules/shuffle.sh'

    shell:"{params.script_path} {input} {output}"

rule compress_fastq:
    input: 'simreads/{community}/simrep_{rep}/R{rd}.fq'

    output: 'simreads/{community}/simrep_{rep}/R{rd}.fq.gz'

    shell: "gzip {input}"


